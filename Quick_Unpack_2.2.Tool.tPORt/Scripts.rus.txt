Для начала строго рекомендуется прочитать этот мануал внимательно и до конца. Если вы будете тыкать всё подряд в абы каком порядке, в лучшем случае это приведёт к падению программы, в худшем будет BSOD и потенциальная возможность потери данных. Не все функции можно вызывать в произвольном порядке, не все указанные функции следует вызывать, часть была выведена в основном для внутреннего пользования, обо всём этом там чётко написано.
О написании скриптов можно посмотреть в мануале по скриптовому языку Lua (включён в поставку в папке Scripts (Lua Manual.html), также www.lua.org) и посмотреть примеры скриптов в папке Scripts (файлы *.txt).
Если что-то не работает или работает не так, как надо, прочитайте мануал ещё раз 5, потом уже сообщайте о багах. :)
А теперь дополнительные функции и переменные, которые можно вызывать и использовать в своих скриптах.

---------------------------------------------------------------
Функции
---------------------------------------------------------------

number AddBreak(number where,number type1,number type2)
where-адрес, куда поставить бряк
type1-может принимать следующие значения:
	1-бряк опкодный (1 байт), отличается от стандартного лишь другим опкодом, что добавляет немного скрытности
	2-бряк стандартный и всем известный 0xCC, куда ж без него
	3-бряк аппаратный в регистр DR0
	4-бряк аппаратный в регистр DR1
	5-бряк аппаратный в регистр DR2
	6-бряк аппаратный в регистр DR3
type2-на что поставить бряк, может принимать следущие значения: 0-на исполнение, 1-на запись в память, 2-на запись и чтение памяти. Данное поле применимо только к отладочным регистрам (значение type1=3-6), в остальных случаях может принимать любое значение.
result-true, если бряк включён; false-если произошла ошибка (слишком много бряков, например (см. DeleteBreak()))
Функция добавляет бряк в список бряков. Следует иметь в виду, что по умолчанию он не включён (см. EnableBreak()).
Аппаратные бряки на чтение и чтение+запись существуют, но в программе ни разу не использовались+некоторые компетентные товарищи говорят, что они могут приводить к BSOD, поэтому их использование не оттестировано и нежелательно

number AddSection(string name,string body, number size)
name-имя секции
body-тело секции, что будет в неё записано
size-размер секции, должен равняться размеру данных в теле
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Функция добавляет в конец сдампленного файла секцию с указанным именем указанного размера и записывает в неё указанные данные. Файл сначала должен быть сдамплен (см. Dump())

number Attach()
result-всегда 0
Функция позволяет аттачиться к запущенному процессу, аналогично нажатию кнопки Attach to process в главном окне программы. При этом вся информация о ранее распаковываемом процессе будет утеряна. Функция не особо оттестирована, поэтому лучше ей не злоупотреблять

number AttachFast(number PID,number thread_id)
PID-id процесса для аттача
thread_id-id потока в этом процессе
result-всегда 0
Функция аналогична функции Attach(), только не показывает окна с процессами. Она использует все текущие настройки и меняет только процесс и поток (полезно, когда пакер использует 2 потока как Armadillo)

number CleanImport()
result-всегда 0
Очищает таблицу импорта для распаковываемого файла

number Continue(bool skiphooked)
skiphooked-вернёт ли функция управление при попадании на бряк похуканной таблицы экспорта или продолжит выполнение дальше
result-всегда 0
Отпускает программу на выполнение, аналог Run в Ольке. Следует иметь в виду, что при остановке на бряке, данный бряк автоматически отключается (см. EnableBreak()). Также программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

bool DeleteBreak(number where)
where-адрес бряка
result-true, если бряк удален; false-если произошла ошибка (бряк не найден в списке, например)
Удалить бряк по указанному адресу из списка бряков

number DeleteLastSection()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Функция удаляет последнюю секцию в сдампленом файле. Файл сначала должен быть сдамплен (см. Dump())

number Detach()
result-всегда 0
Функция позволяет отцепиться от запущенного процесса. Функция не особо оттестирована, поэтому лучше ей не злоупотреблять

bool DisableBreak(number where)
where-адрес бряка
result-true, если бряк выключен; false-если произошла ошибка (бряк не найден в списке, например)
Отключить бряк по указанному адресу

number DisableBreakAll()
result-всегда 0
Отключить все бряки

bool Disasm(number where)
where-адрес, откуда дизассемблировать
result-true, если всё нормально; false, если случилась ошибка (память не может быть прочитана, например)
Функция дизассембирует код по указанному адресу и показывает его пользователю

number Dump()
result-возращает 0, если сдампилось успешно; -1, если произошла ошибка (например, процесс помер уже)
Сделать дамп процесса. Процесс для распаковки дампится в память. Необходимо с ним далее проделать нужные вещи (импорт, релоки, ТЛС, оверлей), а затем уже сохранить (см. SaveFile())

number DumpForRelocs()
result-возращает 0, если сдампилось успешно; -1, если произошла ошибка (например, процесс помер уже)
Для восстановления релоков (только для DLL) необходимо либо запустить дополнительную загрузку DLL (см. PreLoad()), либо воспользоваться этой функцией. В DLL необходимо дойти до OEP, а затем запустить эту функцию. Далее процесс необходимо убить и запустить заново, уже потом можно будет вызывать RestoreImportRelocs()

number EmulateRDTSC(number active,number shift)
active-принимает 2 значения: 0-выключить эмуляцию, 1-включить эмуляцию
shift-насколько сильно будут разниться значения для двух последовательных вызовов инструкции RDTSC. Рекомендуется ставить 0х100, при необходимости уже варьировать
result-всегда 0
Функция требует хука 1 и 13 прерывания (см. Hook()) и общается напрямую с драйвером, лишний раз её лучше не дёргать. По умолчанию выключена

bool EnableBreak(number where)
where-адрес бряка
result-true, если бряк включён; false-если произошла ошибка (бряк не найден в списке, например)
Включить бряк по указанному адресу. Следует иметь в виду, что бряк после добавления надо ещё и включать, ибо по дефолту он не включён. Также следует его включать и после остановки на нём. Ибо если программа остановилась на бряке, он автоматически выключается

number ExecuteFunction(string library, string function, number arg1, number arg2, number arg3, number arg4, number arg5)
library-имя библиотеки, из которой должна быть выполнена функция
function-имя функции для выполнения
arg1-arg5-список аргументов для функции
result-возвращает значение регистра eax после выполнения функции в случае успеха; -1, если произошла ошибка (например, библиотека не найдена)
Функция выполняет указанную функцию из указанной библиотеки с указанными параметрами в контексте распаковываемой программы. При вызове этой функции библиотека автоматически подгружается в процесс (см. LoadExtraLibrary()). Следует иметь в виду, что аргументов должно быть передано именно 5! Если функция принимает меньше аргументов, дополнить нулями

number Find(string buf,number length,number start,number end)
buf-строка с данными для поиска
length-размер данных в buf в байтах
start-адрес начала поиска в VA
end-адрес окончания поиска в VA
result-адрес, по которому найдено; 0 в случае ошибки (например, процесс уже помер) или не найдено
Функция ищет указанную последовательность байтов с указанного адреса по указанный адрес, возвращая найденный адрес или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке. Функция ищет точную последовательность байтов, поэтому и буфер должен содержать точные байты (пример: "\104\101\108\108\111")

number FindByMask(string buf,number length,number start,number end)
buf-строка с данными для поиска
length-размер данных в buf в байтах
start-адрес начала поиска в VA
end-адрес окончания поиска в VA
result-адрес, по которому найдено; 0 в случае ошибки (например, процесс уже помер) или не найдено
Функция ищет указанную последовательность байтов с указанного адреса по указанный адрес, возвращая найденный адрес или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке. Функция позволяет использовать маску (пример: "558?EC")

number FindOEP()
result-OEP программы; 0 в случае ошибки
Показывает стандартное и всем известное окошко выбора OEP finder, результат работы которого и возвращает данная функция

number FullUnpack()
result-всегда 0
Основная функция для полной распаковки. Именно она вызывается при нажатии на кнопку Full unpack в главном окне программы. Для её работы необходимо выставить все начальные значения в главном окне программы

number GetProcAddress(string library,string function)
library-имя библиотеки с функцией, адрес которой нужно получить
function-имя функции, адрес которой нужно получить
result-возвращает адрес функции из библиотеки; 0 в случае ошибки (например, функция не найдена)
Функция возвращает адрес указанной функции из указанной библиотеки или 0 в случае ошибки

number Hook(number victim_id, number int1, number int3, number int4, number int6, number int13)
victim_id-PID распаковываемого процесса
int1,int3,int4,int6,int13-что делать с прерыванием, принимает следующие значения: 0-ничего не делать, 1-захучить прерывание, 2-расхучить прерывание
result-всегда 0
Данная функция посылает команду непосредственно драйверу. Сделана в основном для внутреннего пользования, строго не рекомендуется её трогать, иначе можно получить BSOD. По умолчанию все прерывания похуканы, а victim_id настроен на распаковываемый процесс

number ImportAdd(number RVA)
RVA-адрес инструкции, которая использует импорт (call dword ptr[xxx], jmp dword ptr[xxx], mov eax,dword ptr[xxx] и т. д.)
result-0 при успехе; 1 при ошибке чтения указанной памяти; 2, если не похоже, что инструкция использует импорт; 3, если функция не было распознана
Функция использует только статические методы для распознания функций, в случае перенаправленного импорта она не справится (см. ImportTraceAdd())

number ImportTraceAdd(number RVA)
RVA-адрес инструкции, которая использует импорт (call dword ptr[xxx], jmp dword ptr[xxx], mov eax,dword ptr[xxx] и т. д.)
result-0 при успехе; 1 при ошибке чтения указанной памяти; 2, если не похоже, что инструкция использует импорт; 3, если трассировка обломалась
Функция использует трассировку для распознания функций

number/string InputValue(string caption,string default)
caption-заголовок окна ввода
default-значение по умолчанию, которое будет выведено в строке ввода
result-возвращает строку или число, которая была введена; -1, если была нажата кнопка cancel
Функция показывает окно с указанным заголовком и строкой для ввода и возвращает введённую строку или число или -1

bool IsEnabled(number where)
where-адрес бряка
result-true, если бряк включён; false-если бряк выключен или произошла ошибка (бряк не найден в списке, например)
Функция позволяет проверить, включён ли бряк по указанному адресу. Сделана на всякий случай для людей с плохой памятью :)

bool IsExist(number where)
where-адрес бряка
result-true, если бряк существует; false-если бряк не существует
Функция позволяет проверить, существует ли бряк по указанному адресу. Сделана на всякий случай для людей с плохой памятью :)

number LoadExtraLibrary(string library)
library-имя библиотеки, которую нужно загрузить
result-возвращает 0, если успешно загружено; -1, если произошла ошибка (например, библиотека не найдена)
Функция загружает указанную библиотеку в адресное пространство распаковываемой программы

number ModuleAddHook(number module_base)
module_base-imagebase модуля
result-всегда 0
Функция добавляет модуль с указанным imagebase в список модулей и хукает его экспорт, если стоит соотвтвующая опция (см. import_meth)

number NextInstr(number where)
where-адрес инструкции
result-возвращает адрес следующей инструкции; 0 в случае ошибки (например, плохой адрес)
Функция для заданного адреса инструкции возвращает адрес следующей за ней инструкции

number Pause(string message)
message-сообщение, которое будет показано в MessageBox
result-всегда 0
Функция приостанавливает выполнение скрипта и показывает сообщение. После нажатия кнопки OK в окне сообщения выполнение скрипта продолжится

number PreLoad()
result-0, если процесс был насильно убит; 1-если функция успешно отработала или же это EXE файл и галка Use force unpacking не стоит
Функция используется для Force unpacking (что это такое, можно прочитать в Readme.rus.txt), также она позволяет восстановить релоки (только для DLL). Перед восстановлением релоков (см. RestoreImportRelocs()) необходимо вызывать либо эту функцию, либо см. DumpForRelocs(). Перед использованием этой функции необходимо выставить в главном окне OEP (также см. jmp_to_oep). Она отличается от DumpForRelocs() тем, что сама проходит до указанного OEP и сама убивает процесс; в DumpForRelocs() до OEP придётся идти руками, процесс придётся убивать также руками (см. Terminate())

number ProcessRelocs()
result-всегда 0
Обрабатывает и сохраняет релоки. Может быть использовано и для EXE файла, при этом просто зануляет указатель в заголовке

number ProcessResourcesCutSections()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Функция вызывается для отрезания лишних секций и перестройки ресурсов (ибо старые ресурсы отрезаются). При этом перестроенные ресурсы сразу в файл не сохраняются (см. SaveResources()). При отрезании секций порой необходимо восстановить также и ТЛС (см. ProcessTLS()). Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number ProcessTLS()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Восстановить ТЛС в файле. ТЛС сразу пишется в отдельную секцию .tls. Вызывать её необязательно. Только если изначально ТЛС не попадает в файл (в основном при отрезании секций (см. ProcessResourcesCutSections())), необходима перестройка. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number ReadMem(number where,number size)
where-адрес, откуда читать данные
size-размер данных для чтения в байтах, может принимать следующие значения: 1, 2, 3, 4
result-возвращает прочитанные байты; 0+запись об ошибке в лог в случае ошибки (например, процесс уже помер)
Функция читает указанные данные по указанному адресу, возвращая прочитанные байты или 0 в случае ошибки. Порядок байтов в результате обратный порядку байтов в памяти

number ReadMemDump(number where,number size)
where-адрес, откуда читать данные, указывается в RVA!
size-размер данных для чтения в байтах, может принимать следующие значения: 1, 2, 4
result-возвращает прочитанные байты; 0 в случае ошибки
Функция идентична функции ReadMem(), но только читает данные из дампа. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

string ReadMemLarge(number where,number size)
where-адрес, откуда читать данные
size-размер данных для чтения в байтах
result-возвращает строку с прочитанными байтами
Функция читает указанные данные по указанному адресу, возвращая строку с прочитанными байтами. Порядок байтов в результате такой же, как и порядок байтов в памяти

number RemoveLastSEH(number handler)
handler-адрес обработчика в выделенной памяти, который вернула SetLastSEH()
result-всегда 0
Функция удаляет новый обработчик SEH, установленный в SetLastSEH(), и может быть использована во время ручного восстановления импорта, чтобы избежать падения программы, когда трассируется неверная функция

number RestoreImportRelocs()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс уже помер)
Функция позволяет восстановить импорт и релоки (только для DLL, для восстановления релоков необходим Use force unpacking (см. PreLoad()) или DumpForRelocs()) с импользованием выбранного метода (см. import_meth). Они сразу же пишутся в отдельные секции .idata и .relocs. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number Resume()
result-всегда 0
Вернуть отлаживаемый поток из спячки и заполнить кое-какие отладочные структуры. В основном используется для внутренних целей

number ResumeAllOther()
result-всегда 0
Вернуть все остальные потоки из спячки и заполнить кое-какие отладочные структуры. В основном используется для внутренних целей, но может использоваться и при ручном восстановлении импорта, чтобы другие потоки не мешали

number SaveFile()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить файл на диск. При этом сдампленный файл сохраняется из памяти на диск. Следует вызывать в последнюю очередь, когда файл уже сдамплен, восстановлен импорт и, при необходимости, релоки, ТЛС и оверлей

number SaveImport()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить импорт в файл. Следует вызывать после того, как файл уже сдамплен

number SaveOverlay()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Прицепить оверлей к файлу. Оверлей берётся из исходного файла и цепляется в конец. Следует вызывать непосредственно перед сохранением файла и после того, как файл уже сдамплен, восстановлен импорт и, при необходимости, релоки и ТЛС

number SaveResources()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Сохранить ресурсы в отдельную секцию .rsrc. Следует вызывать уже после того, как ресурсы были выдраны из файла (см. ProcessResourcesCutSections())

number SetLastSEH()
result-адрес обработчика в выделенной памяти
Функция устанавливает новый обработчик SEH, и может быть использована во время ручного восстановления импорта, чтобы избежать падения программы, когда трассируется неверная функция

number SetMainBreaks()
result-всегда 0
Установить основные бряки. Вызывается обычно непосредственно после Start() или Attach() и позволяет следить за подгружаемыми модулями, хучить в них экспорт (если стоит соответствующая опция, см. import_meth) и защищать отладочные регистры от просмотра и именения (если стоит соответствующая опция, см. protect_dr). Вызывать её желательно, но иногда лучше и не трогать (если программа отказывается с ней запускаться)

number ShowImport()
result-возвращает 0 в случае успеха; -1 в случае ошибки (например, процесс не дампился, см. Dump())
Показывает окошко с таблицей импорта, где импорт можно править вручную

number Start()
result-всегда 0
Функция загружает файл. Позволяет загружать как EXE, так и DLL файлы. При этом процесс запускается, ставится бряк на EP или на TLS Callback, и программа останавливается на этом бряке

number Stop()
result-всегда 0
Функция останавливает процесс распаковки. При этом поток с распаковкой убивается (аналогично нажатию кнопки Kill target в главном окне программы)

number Suspend()
result-всегда 0
Отправить отлаживаемый поток в спячку. В основном используется для внутренних целей

number SuspendAllOther()
result-всегда 0
Отправить все остальные потоки в спячку. В основном используется для внутренних целей, но может использоваться и при ручном восстановлении импорта, чтобы другие потоки не мешали

number Terminate()
result-всегда 0
Убить процесс распаковываемой программы. При этом стирается вся информация о процессе, какая-либо дальнейшая работа с ним невозможна

number Trace()
result-всегда 0
Сделать один шаг с использованием TF (trace flag). Не стоит этим увлекаться, ибо работает медленно и может быть обнаружено антиотладкой. Программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

number TraceAndReplace(number where)
where-адрес для трассировки
result-всегда 0
Функция с использованием TF (trace flag) проходит бряк по установленному адресу и восстанавливает бряк. Связано это с автоматическим выключением бряков (см. EnableBreak()) и используется в основном для внутренних целей. Программа может неожиданно помереть, неплохо бы это проверить прежде, чем что-то ещё с ней делать (см. break_where)

number Wait()
result-всегда 0
Функция крутится в цикле обработки бряков и заполняет кое-какие отладочные структуры. В основном используется для внутренних целей

number WriteEx(string line, bool dobreak, bool bald, number textcolor)
line-строчка для выведения в лог
dobreak-нужно ли переносить вывод на новую строку
bald-выводить ли жирным шрифтом
textcolor-цвет текста
result-всегда 0
Служит для продвинутого вывода в лог любой информации. На месте line не обязательно может быть строчка (см. WriteLog())

number WriteLog(string line)
line-строчка для выведения в лог
result-всегда 0
Служит для вывода в лог любой информации. На месте line не обязательно может быть строчка, можно использовать и, например, так: WriteLog(EAX)

number WriteMem(number where,number buf,number size)
where-адрес, куда писать данные
buf-переменная, содержащая данные для записи
size-размер данных для записи в байтах, может принимать следующие значения: 1, 2, 3, 4
result-возвращает число байт, которые были записаны; 0 в случае ошибки (например, процесс уже помер)
Функция пишет указанные данные по указанному адресу, возвращая число записанных байтов или 0 в случае ошибки. Порядок байтов в памяти обратный порядку байтов в переменной

number WriteMemDump(number where,number buf,number size)
where-адрес, куда писать данные, указывается в RVA!
buf-переменная, содержащая данные для записи
size-размер данных для записи в байтах, может принимать следующие значения: 1, 2, 4
result-возвращает число байт, которые были записаны; 0 в случае ошибки
Функция идентична функции WriteMem(), но только пишет данные в дамп. Функцию следует вызывать после того, как файл уже сдамплен (см. Dump())

number WriteMemLarge(number where,string buf,number size)
where-адрес, куда писать данные
buf-строка, содержащая данные для записи
size-размер данных для записи в байтах
result-возвращает число байт, которые были записаны; 0 в случае ошибки (например, процесс уже помер)
Функция пишет указанные данные по указанному адресу, возвращая число записанных байтов или 0 в случае ошибки. Порядок байтов в памяти такой же, как и порядок байтов в строке

---------------------------------------------------------------
Переменные
---------------------------------------------------------------

number break_where-адрес, на котором произошёл текущий останов программы, также может принимать следующие значения для обозначения особых событий:
	0xf00-процесс помер. Бывает, что прога подыхает. Чтоб не гонять скрипт дальше, после выполнения кода (см. Continue(), Trace(), TraceAndReplace()) неплохо бы это проверить
	0xf10-SingleStep. Возникает при использовании TF (trace flag), используется для внутренних целей
	0xf20-произошёл останов на функции при похуканной таблице экспорта модулей, используется для внутренних целей
	0xf30-bUnhandledSingleStep. Произошёл SingleStep, но был вызван не нами, используется для внутренних целей
	0xf31-bUnhandledBreak. Произошёл Break, но был вызван не нами, используется для внутренних целей
	0xf32-bUnhandledBreakAlt. Произошёл BreakAlt, но был вызван не нами, используется для внутренних целей
	0xf40-bDr0. Произошёл аппаратный бряк по регистру Dr0
	0xf41-bDr1. Произошёл аппаратный бряк по регистру Dr1
	0xf42-bDr2. Произошёл аппаратный бряк по регистру Dr2
	0xf43-bDr3. Произошёл аппаратный бряк по регистру Dr3

bool delphi_init-включать или нет восстановление таблицы инициализации для Delphi. Следует включать только при уверенности, что програма действительно написана на Delphi. По умолчанию стоит в false

bool execute_functions-включать или нет выполнение функций при трассировке импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number image_size-размер образа, эта переменная только для чтения и после дампа (см. Dump()) возращает размер образа, до дампа 0

number import_meth-метод восстановления импорта, от него зависит, будет ли хукаться экспорт у подгруженных модулей (см. SetMainBreaks()) и сам способ восстановления импорта (см. RestoreImportRelocs()), может принимать следующие значения: 0-соответствует Do not recover, 1-соответствует Smart method, 2-соответствует Smart method+tracer, 3-соответствует Load libraries only. Таблица экспорта подгруженных модулей будет хукаться, если эта переменная равна 1 или 2. По умолчанию стоит в положении, соответствующем переключателю в главном окне программы

number import_rva-положить таблицу импорта по этому RVA вместо создания новой секции. По умолчанию принимает значение Import RVA, указанное в главном окне программы

number jmp_to_oep-OEP для распаковываемой программы, может использоваться для PreLoad(). По умолчанию принимает значение OEP, указанное в главном окне программы

number module_end-считать это число концом модуля при обработке импорта. Это число используется для пропуска указателей, которые ведут внутрь модуля. Это RVA! По умолчанию принимает значение конца модуля, указанное в главном окне программы

string packer-пакер, которым было упаковано приложение

string parameters-параметры, которые будут переданы распаковываемому приложению. По умолчанию принимает значение Parameters, указанное в главном окне программы

bool protect_dr-включать или нет защиту отладочных регистров. Сама по себе защита будет работать только при вызове соответствующей функции (см. SetMainBreaks()). По умолчанию стоит в true

number rdtsc_delta-два вызова инструкции RDTSC или функции GetTickCount один за другим покажут разницу в random(0-255)+delta. Следует помнить, что хук глобальный в системе. По умолчанию принимает значение Time delta, указанное в главном окне программы

bool suspect_calls-включать или нет функции типа call xxx/jmp xxx в таблицу импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

bool suspect_functions-включать или нет подозрительные функции в таблицу импорта. По умолчанию принимает значение соответствующего переключателя в главном окне программы

number thread_id-ID текущего потока в распаковываемом процессе. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number version-равна 220. не следует менять это значение. нужно только для того, чтобы решить, запускать ли скипт под какой-либо версией. я не собираюсь обеспечивать полную совместимость с прошлыми версиями, чтобы не превратить QuickUnpack в виндо-подобного монстра :) поэтому скрипт лучше запускать только на той версии, для которой он предназначен, хотя в основном буду стараться делать совместимыми с прошлыми версиями

number victim_base-imagebase, по которому загружен файл для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number victim_handle-хендл процесса для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

number victim_id-PID процесса для распаковки. В основном служит для внутренних целей, поэтому трогать его строго не рекомендуется

Состояние распаковываемого процесса описывается следующими переменными:
number EAX-регистр eax
number EBX-регистр ebx
number ECX-регистр ecx
number EDX-регистр edx
number EIP-регистр eip
number EBP-регистр ebp
number ESP-регистр esp
number ESI-регистр esi
number EDI-регистр edi
number EFLAGS-регистр eflags. Менять не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR0-регистр dr0. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR1-регистр dr1. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR2-регистр dr2. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR3-регистр dr3. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR6-регистр dr6. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number DR7-регистр dr7. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD
number CS-регистр cs. Менять строго не рекомендуется. Если менять, не используя мозг, можно получить BSOD